var documenterSearchIndex = {"docs":
[{"location":"pi_mcmc/#PiMCMC","page":"PiMCMC","title":"PiMCMC","text":"","category":"section"},{"location":"pi_mcmc/#Types","page":"PiMCMC","title":"Types","text":"","category":"section"},{"location":"pi_mcmc/","page":"PiMCMC","title":"PiMCMC","text":"AbstractPiMCMC\nPiMCMC","category":"page"},{"location":"pi_mcmc/#MCMC.AbstractPiMCMC","page":"PiMCMC","title":"MCMC.AbstractPiMCMC","text":"AbstractPiMCMC <: AbstractMCMC\n\nAbstract type for PiMCMC algorithms. Concrete subtypes must have implemented either a method for the state and for the random number generator or have them as fields as state and rng.\n\n\n\n\n\n","category":"type"},{"location":"pi_mcmc/#MCMC.PiMCMC","page":"PiMCMC","title":"MCMC.PiMCMC","text":"PiMCMC <: AbstractPiMCMC <: AbstractMCMC\n\nConcrete type for PiMCMC algorithms. \n\nThe rng is a Xoshiro, by default it seeded with the default generator.\n\nThe checkpointfile is defaulted using [`defaultcheckpointfile`](@ref defaultcheckpoint_file).\n\nThe savefile is defaulted using [`defaultsavefile`](@ref defaultsave_file).\n\nThe closing of the file is automatically handled by the finalizer.\n\nThe rng_state method is implemented for the type, but not the should_save.\n\n\n\n\n\n","category":"type"},{"location":"pi_mcmc/#Methods","page":"PiMCMC","title":"Methods","text":"","category":"section"},{"location":"pi_mcmc/","page":"PiMCMC","title":"PiMCMC","text":"state(::AbstractPiMCMC)\nrng(::AbstractPiMCMC)\nsample(::AbstractPiMCMC)\nupdate!(::AbstractPiMCMC, ::Vector{Float64})\nobservables(::AbstractPiMCMC)\nBase.write(::HDF5.File, ::String, ::AbstractPiMCMC)\nrng_state(::PiMCMC)","category":"page"},{"location":"pi_mcmc/#MCMC.state-Tuple{AbstractPiMCMC}","page":"PiMCMC","title":"MCMC.state","text":"state(mcmc::AbstractPiMCMC)\n\nReturns the state of the MCMC as a field.\n\n\n\n\n\n","category":"method"},{"location":"pi_mcmc/#MCMC.rng-Tuple{AbstractPiMCMC}","page":"PiMCMC","title":"MCMC.rng","text":"rng(mcmc::AbstractPiMCMC)\n\nReturns the random number generator of the MCMC as a field.\n\n\n\n\n\n","category":"method"},{"location":"pi_mcmc/#MCMC.sample-Tuple{AbstractPiMCMC}","page":"PiMCMC","title":"MCMC.sample","text":"sample(mcmc::AbstractPiMCMC)\n\nSample a new point in the [0, 1]Ã—[0, 1] square.\n\n\n\n\n\n","category":"method"},{"location":"pi_mcmc/#MCMC.update!-Tuple{AbstractPiMCMC, Vector{Float64}}","page":"PiMCMC","title":"MCMC.update!","text":"update!(mcmc::AbstractPiMCMC, x_test::Vector{Float64})\n\nUpdate the state of the MCMC with the new point, return always true.\n\n\n\n\n\n","category":"method"},{"location":"pi_mcmc/#MCMC.observables-Tuple{AbstractPiMCMC}","page":"PiMCMC","title":"MCMC.observables","text":"observables(mcmc::AbstractPiMCMC)\n\nReturns the observables of the PiMCMC.\n\n\n\n\n\n","category":"method"},{"location":"pi_mcmc/#Base.write-Tuple{HDF5.File, String, AbstractPiMCMC}","page":"PiMCMC","title":"Base.write","text":"HDF5.write(file::HDF5.File, group_name::String, mcmc::AbstractPiMCMC)\n\nWrite the state of the MCMC to the HDF5 file. The concrete type must have implemented rng_state \n\n\n\n\n\n","category":"method"},{"location":"pi_mcmc/#MCMC.rng_state-Tuple{PiMCMC}","page":"PiMCMC","title":"MCMC.rng_state","text":"rng_state(mcmc::PiMCMC)\n\nReturns the state of the Xoshiro rng as a vector.\n\n\n\n\n\n","category":"method"},{"location":"#MCMC","page":"Home","title":"MCMC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A simple module for Markow Chain Monte Carlo created as final project for the julia workshop at AISF Pisa","category":"page"},{"location":"abstract_mcmc/#Abstract-MCMC","page":"Abstract MCMC","title":"Abstract MCMC","text":"","category":"section"},{"location":"abstract_mcmc/#Types","page":"Abstract MCMC","title":"Types","text":"","category":"section"},{"location":"abstract_mcmc/","page":"Abstract MCMC","title":"Abstract MCMC","text":"AbstractMCMC","category":"page"},{"location":"abstract_mcmc/#MCMC.AbstractMCMC","page":"Abstract MCMC","title":"MCMC.AbstractMCMC","text":"AbstractMCMC\n\nSupertype for all MCMC algorithms. It provides a common interface  for sampling, updating, and saving the MCMC state.\n\nAll subtypes of AbstractMCMC should implement the following methods:\n\nsample(<:AbstractMCMC): Sample a new point from the proposal distribution.\nupdate!(<:AbstractMCMC, x_test): Update the MCMC state with the new point. It should return\n\ntrue if the configuration has been modified, and false otherwise.\n\nOptionally subtypes of AbstractMCMC can overload the function should_save to define when the MCMC state should be saved. By default, the state will never be saved. In order to save the state, the method HDF5.write(::HDF5.File, ::String, <:AbstractMCMC) must be defined.\n\nFurthermore the following symbols should be defined for the subtype either as fields or as methods:\n\nrng(<:AbstractMCMC): Return the random number generator to be used for sampling. \nobservables(<:AbstractMCMC): Return a list of observables to be computed, \n\nobservables must be functions that take the mcmc as argument.\n\nsave_file(<:AbstractMCMC): Return an IO stream where the the obervables output will be saved.\ncheckpoint_file(<:AbstractMCMC): Return the filename to save the MCMC state. Alternatively, \n\na checkpoint_file field can be defined for the subtype.\n\n\n\n\n\n","category":"type"},{"location":"abstract_mcmc/#Methods","page":"Abstract MCMC","title":"Methods","text":"","category":"section"},{"location":"abstract_mcmc/","page":"Abstract MCMC","title":"Abstract MCMC","text":"checkpoint_file\nsave_file\nrng\nobservables\nshould_save\nsave!\nrun!","category":"page"},{"location":"abstract_mcmc/#MCMC.checkpoint_file","page":"Abstract MCMC","title":"MCMC.checkpoint_file","text":"checkpoint_file(mcmc::AbstractMCMC)\n\nIf the concrete subtype of AbstractMCMC has checkpoint_file as a field, it will be returned, otherwise a MethodError will be thrown. \n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.save_file","page":"Abstract MCMC","title":"MCMC.save_file","text":"save_file(mcmc::AbstractMCMC)\n\nIf the concrete subtype of AbstractMCMC has save_file as a field, it will be returned, otherwise a MethodError will be thrown. \n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.rng","page":"Abstract MCMC","title":"MCMC.rng","text":"rng(mcmc::AbstractMCMC)\n\nIf the concrete subtype of AbstractMCMC has rng as a field, it will be returned, otherwise a MethodError will be thrown. \n\n\n\n\n\nrng(mcmc::AbstractPiMCMC)\n\nReturns the random number generator of the MCMC as a field.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.observables","page":"Abstract MCMC","title":"MCMC.observables","text":"observables(mcmc::AbstractMCMC)\n\nIf the concrete subtype of AbstractMCMC has observables as a field, it will be returned, otherwise a MethodError will be thrown. \n\n\n\n\n\nobservables(mcmc::AbstractPiMCMC)\n\nReturns the observables of the PiMCMC.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.should_save","page":"Abstract MCMC","title":"MCMC.should_save","text":"should_save(mcmc::AbstractMCMC, i::Int)\n\nDetermine if the MCMC state should be saved. By default, it returns false. Subtypes of AbstractMCMC can overload this function to define when the state should be saved. The default implementation is to never save the state.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.save!","page":"Abstract MCMC","title":"MCMC.save!","text":"save!(mcmc::AbstractMCMC)\n\nSave the MCMC state to the checkpoint HDF5 file calling HDF5.write.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.run!","page":"Abstract MCMC","title":"MCMC.run!","text":"run!(mcmc::AbstractMCMC, n::Int)\n\nRun the MCMC algorithm for n iterations. It will sample a new point, update the configuration, compute the observables and save the state when should_save returns true.\n\nThe steps are logged at debug level. For utility you can use the mcmc_logger function to:\n\nwith_logger(mcmc_logger()) do\n\trun!(mcmc, n)\nend\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/#Functions","page":"Utilities","title":"Functions","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"default_save_file\ndefault_checkpoint_file\nmcmc_logger","category":"page"},{"location":"utils/#MCMC.default_save_file","page":"Utilities","title":"MCMC.default_save_file","text":"default_save_file()\n\nutility function to create a temporary file for saving the output of the MCMC run.\n\n\n\n\n\n","category":"function"},{"location":"utils/#MCMC.default_checkpoint_file","page":"Utilities","title":"MCMC.default_checkpoint_file","text":"default_checkpoint_file()\n\nutility function to create a temporary file for saving the checkpoint of the MCMC run.\n\n\n\n\n\n","category":"function"},{"location":"utils/#MCMC.mcmc_logger","page":"Utilities","title":"MCMC.mcmc_logger","text":"mcmc_logger(every::Int=100)\n\nutility function to create a temporary file for saving the logs of the MCMC run. The logs are printed every every iterations.\n\n\n\n\n\n","category":"function"}]
}
