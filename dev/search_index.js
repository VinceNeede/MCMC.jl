var documenterSearchIndex = {"docs":
[{"location":"#MCMC","page":"Home","title":"MCMC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A simple module for Markow Chain Monte Carlo created as final project for the julia workshop at AISF Pisa","category":"page"},{"location":"abstract_mcmc/#Abstract-MCMC","page":"Abstract MCMC","title":"Abstract MCMC","text":"","category":"section"},{"location":"abstract_mcmc/#Types","page":"Abstract MCMC","title":"Types","text":"","category":"section"},{"location":"abstract_mcmc/","page":"Abstract MCMC","title":"Abstract MCMC","text":"AbstractMCMC","category":"page"},{"location":"abstract_mcmc/#MCMC.AbstractMCMC","page":"Abstract MCMC","title":"MCMC.AbstractMCMC","text":"AbstractMCMC\n\nSupertype for all MCMC algorithms. It provides a common interface  for sampling, updating, and saving the MCMC state.\n\nAll subtypes of AbstractMCMC should implement the following methods:\n\nsample(<:AbstractMCMC): Sample a new point from the proposal distribution.\nupdate!(<:AbstractMCMC, x_test): Update the MCMC state with the new point. It should return\n\ntrue if the configuration has been modified, and false otherwise.\n\nOptionally subtypes of AbstractMCMC can overload the function should_save to define when the MCMC state should be saved. By default, the state will never be saved. In order to save the state, the method HDF5.write(::HDF5.File, ::String, <:AbstractMCMC) must be defined.\n\nFurthermore the following symbols should be defined for the subtype either as fields or as methods:\n\nrng(<:AbstractMCMC): Return the random number generator to be used for sampling. \nobservables(<:AbstractMCMC): Return a list of observables to be computed, \n\nobservables must be functions that take the mcmc as argument.\n\nsave_file(<:AbstractMCMC): Return an IO stream where the the obervables output will be saved.\ncheckpoint_file(<:AbstractMCMC): Return the filename to save the MCMC state. Alternatively, \n\na checkpoint_file field can be defined for the subtype.\n\n\n\n\n\n","category":"type"},{"location":"abstract_mcmc/#Methods","page":"Abstract MCMC","title":"Methods","text":"","category":"section"},{"location":"abstract_mcmc/","page":"Abstract MCMC","title":"Abstract MCMC","text":"checkpoint_file\nsave_file\nrng\nobservables\nshould_save\nsave!\nrun!","category":"page"},{"location":"abstract_mcmc/#MCMC.checkpoint_file","page":"Abstract MCMC","title":"MCMC.checkpoint_file","text":"checkpoint_file(mcmc::AbstractMCMC)\n\nIf the concrete subtype of AbstractMCMC has checkpoint_file as a field, it will be returned, otherwise a MethodError will be thrown. \n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.save_file","page":"Abstract MCMC","title":"MCMC.save_file","text":"save_file(mcmc::AbstractMCMC)\n\nIf the concrete subtype of AbstractMCMC has save_file as a field, it will be returned, otherwise a MethodError will be thrown. \n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.rng","page":"Abstract MCMC","title":"MCMC.rng","text":"rng(mcmc::AbstractMCMC)\n\nIf the concrete subtype of AbstractMCMC has rng as a field, it will be returned, otherwise a MethodError will be thrown. \n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.observables","page":"Abstract MCMC","title":"MCMC.observables","text":"observables(mcmc::AbstractMCMC)\n\nIf the concrete subtype of AbstractMCMC has observables as a field, it will be returned, otherwise a MethodError will be thrown. \n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.should_save","page":"Abstract MCMC","title":"MCMC.should_save","text":"should_save(mcmc::AbstractMCMC, i::Int)\n\nDetermine if the MCMC state should be saved. By default, it returns false. Subtypes of AbstractMCMC can overload this function to define when the state should be saved. The default implementation is to never save the state.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.save!","page":"Abstract MCMC","title":"MCMC.save!","text":"save!(mcmc::AbstractMCMC)\n\nSave the MCMC state to the checkpoint HDF5 file calling HDF5.write.\n\n\n\n\n\n","category":"function"},{"location":"abstract_mcmc/#MCMC.run!","page":"Abstract MCMC","title":"MCMC.run!","text":"run!(mcmc::AbstractMCMC, n::Int)\n\nRun the MCMC algorithm for n iterations. It will sample a new point, update the configuration, compute the observables and save the state when should_save returns true.\n\nThe steps are logged at debug level. For utility you can use the mcmc_logger function to:\n\nwith_logger(mcmc_logger()) do\n\trun!(mcmc, n)\nend\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/#Functions","page":"Utilities","title":"Functions","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"default_save_file\ndefault_checkpoint_file\nmcmc_logger","category":"page"},{"location":"utils/#MCMC.default_save_file","page":"Utilities","title":"MCMC.default_save_file","text":"default_save_file()\n\nutility function to create a temporary file for saving the output of the MCMC run.\n\n\n\n\n\n","category":"function"},{"location":"utils/#MCMC.default_checkpoint_file","page":"Utilities","title":"MCMC.default_checkpoint_file","text":"default_checkpoint_file()\n\nutility function to create a temporary file for saving the checkpoint of the MCMC run.\n\n\n\n\n\n","category":"function"},{"location":"utils/#MCMC.mcmc_logger","page":"Utilities","title":"MCMC.mcmc_logger","text":"mcmc_logger(every::Int=100)\n\nutility function to create a temporary file for saving the logs of the MCMC run. The logs are printed every every iterations.\n\n\n\n\n\n","category":"function"}]
}
